package main

import (
	"crypto/tls"
	"crypto/x509"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"time"

	"github.com/sirupsen/logrus"
)

func main() {

	log.SetFlags(log.Lshortfile)

	var caPath string
	flag.StringVar(&caPath, "path", "../certs/ca.crt", "CA certification path")

	caCert, err := ioutil.ReadFile(caPath)
	if err != nil {
		log.Fatal("readfile error")
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	conf := &tls.Config{
		// RootCAs:                  caCertPool,
		InsecureSkipVerify:       true,
		CurvePreferences:         []tls.CurveID{tls.CurveP256},
		PreferServerCipherSuites: true,
		MinVersion:               tls.VersionTLS13,
		MaxVersion:               tls.VersionTLS13,
		CipherSuites: []uint16{
			tls.TLS_AES_128_GCM_SHA256,
		},
	}

	start := time.Now()

	// hitting the proxy first
	// conn, err := tls.Dial("tcp", "localhost:9443", conf)
	// directly hitting the server
	conn, err := tls.Dial("tcp", "localhost:44301", conf)

	elapsed := time.Since(start)
	logrus.WithFields(logrus.Fields{
		"time": elapsed,
	}).Info("client: total handshake took.")

	if err != nil {
		log.Println(err)
		return
	}
	defer conn.Close()

	// state := conn.ConnectionState()
	// fmt.Println("SSL ServerName : " + state.ServerName)
	// fmt.Println("SSL Handshake : ", state.HandshakeComplete)

	// rt := fmt.Sprintf("GET %v HTTP/1.1\r\nHost: %v\r\nConnection: close\r\n\r\n", "/my-btc-usdt-order", "localhost:8443")
	rt05 := fmt.Sprintf("GET %v HTTP/1.1\r\nHost: %v\r\nConnection: close\r\n\r\nDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUBMYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODY\n", "/my-btc-usdt-order", "localhost:44301")
	rt1 := fmt.Sprintf("GET %v HTTP/1.1\r\nHost: %v\r\nConnection: close\r\n\r\nDUMMYBODYDUMMYBODYDUMMDYBODYDUMMYBODBBBBBYDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUBMYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUBMYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODY\n", "/my-btc-usdt-order", "localhost:44301")
	rt2 := fmt.Sprintf("GET %v HTTP/1.1\r\nHost: %v\r\nConnection: close\r\n\r\nDUMMYBDYDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUBMYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUBMYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUBMYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYDDDDUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUMMYBODYDUMMYBODYDUMMYBODYDUMMYBODYUBMYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODYBODYDUMMYBODYDUMMYBODY\n", "/my-btc-usdt-order", "localhost:44301")
	// rt := fmt.Sprintf("GET %v HTTP/1.1\r\nHost: %v\r\nConnection: close\r\n\r\n", "/query?function=TIME_SERIES_INTRADAY&symbol=IBM&interval=1min&apikey=demo", "www.alphavantage.co")

	// go make use of values
	if false {
		log.Println(rt05, rt1, rt2)
	}

	// measure timing
	start2 := time.Now()

	n, err := io.WriteString(conn, rt05)
	if err != nil {
		fmt.Println("SSL Write error :", err.Error(), n)
	}

	logrus.WithFields(logrus.Fields{
		"bytes": n,
	}).Info("client: total bytes written to connection.")

	// reading response
	buf := make([]byte, 1024)
	n2, err := conn.Read(buf)
	if err != nil {
		fmt.Println("SSL Read error : " + err.Error())
		return
	}

	// measure timing
	elapsed2 := time.Since(start2)
	logrus.WithFields(logrus.Fields{
		"time": elapsed2,
	}).Info("client: total record layer rtt took.")

	println(string(buf[:n2]))
}
